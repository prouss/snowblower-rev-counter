<!DOCTYPE html>
<!-- THIS FILE WAS GENERATED BY HTP. DO NOT EDIT! -->
<!-- Source file is in src/rpm-counting.htp. -->
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Snowblower-rev-counter by prouss</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  <meta name="Generator" content="htp 1.18">
</head>
  <body>
    <section class="page-header">
      <h1 class="project-name" style="margin-bottom: 10px;">Snowblower-rev-counter</h1>
      <h2 class="project-tagline" style="margin-bottom: 20px; margin-top: 10px;">snowblower revolution counter</h2>
      <a href="index.html" class="btn">Home</a>
      <a href="https://github.com/prouss/snowblower-rev-counter" class="btn">View on GitHub</a>
      <a href="https://github.com/prouss/snowblower-rev-counter/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/prouss/snowblower-rev-counter/tarball/master" class="btn">Download .tar.gz</a>
    </section>
    <section class="main-content">
              	<h1>Counting and displaying RPM</h1>
	<p>This page contains the information on all activities related to counting and displaying the number of revolutions per minute.</p>
	
	<!---- 05/30/2015: First Prototype --->
   	<hr>
	<a name="FirstPrototype"><h2>05/30/2015: First Prototype</h2></a>
<p>The idea for his first prototype was that we would have some sort of device that would generate a square pulse for each engine revolution.
By measuring the time between two pulses (the <i>t</i> in figure 1 below) we could easily compute the number of revolutions per minutes (RPM).</p>
<figure>
	<img src="images/measuring-time-between pulses.png" alt="Measuring elapsed time between two pulses">
	<figcaption>Figure 1 - Measuring elapsed time between two pulses</figcaption>
</figure>
<p>Inspired by a robotic lab at high school where he had to measure the length of a pulse in order to evaluate the distance measured by a HC-SR04 sonar, Étienne wrote an Arduino
sketch for measuring the time between two pulses, convert it to RPM, and display it on a LCD. The code for this sketch is shown in figure 2.
<figure>
	<div class="code">
<pre>#include <Arduino.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x27,16,2);

void setup()
{
  lcd.init();
  lcd.backlight();
  pinMode(3,INPUT);
}

int RPM()
{
  unsigned long gap = pulseIn(3,LOW) + pulseIn(3,HIGH);
  int rpm = 0;
  if (gap != 0)
  {
    rpm = 60000000/gap;
  }
  return rpm;
}

void loop()
{
  int rpm = RPM();
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print(rpm);
  delay(500);
}</pre>
	</div>
	<figcaption>Figure 2 - Code for counting RPM</figcaption>
</figure>
<p>In order to test the RPM counting sketch, Étienne wrote a second sketch for generating pulses at specific frequencies.
The code for this sketch is shown in figure 3.<p>
<figure>
	<div class="code">
<pre>void setup()
{
  pinMode(3,OUTPUT);
}

int rpm = 2000;
unsigned long gap = 60000/rpm;
  
void loop()
{
  digitalWrite(3,LOW);
  delay(gap);
  digitalWrite(3,HIGH);
  delay(1);
}</pre>
	</div>
	<figcaption>Figure 3 - Code for generating pulses</figcaption>
</figure>
<p>The figure 4 shows two Arduinos running the two sketches. The Arduino connected to a PC with a USB cable is the pulse generator.
The Arduino connected to the display is the one that measure the elapsed time between two pulses and convert that to RPM.<p>
<figure>
		<a href="images/2015-06-06 10.49.03.jpg"><img src="images/small 2015-06-06 10.49.03.jpg" alt="Initial prototype"></a>
	<figcaption>Figure 4 - Two Arduinos: the pulse generator and the RPM counter</figcaption>
</figure>
<p>Using the PC, Étienne ran the generator at different frequencies (by modifying the rpm variable in the sketch) and he notices that the displayed RPM was not exactly matching the frequency of the generator.
This is due to the timing of some instructions that is not accounted for. We will fix that at a later time.<p>
	
	
	<!---- 06/20/2015: Using a 3.3v Arduino --->
	<hr>
    <a name="MiniPro33"><h2>06/20/2015: Using a 3.3v Arduino</h2></a>
We used a 3.3v Arduino mini pro instead of the original 5v Arduino, and we added a 5v to 3.3v level converter between the Arduino and the LCD. We are running the same code as in the original prototype. Nothing else was changed.<p>
<figure>
		<a href="images/2015-06-20 10.51.10.jpg"><img src="images/small 2015-06-20 10.51.10.jpg" alt="RPM counting using a 3.3v Arduino"></a>
	<figcaption>Figure 5 - RPM counting using a 3.3v Arduino</figcaption>
</figure>
<p>The top Arduino Uno (in blue) is running the pulse generator sketch. The 3.3v Arduino mini pro (with the red led on the bread board) is running the RPM counting sketch.
The cable attached to the LCD is leading to the level converter in the middle of the screen.</p>
	
	
	<!---- 06/27/2015: Count pulses and compute RPM with interrupt --->
	<hr>
    <a name="CountPulsesWithInterrupt"><h2>06/27/2015: Count pulses and compute RPM with interrupt</h2></a>
<p>This week, we modified the code to use an ISR (interrupt service routine) to count the RPM.
In this version of the code, we use the pin 8 to receive pulses from the engine.
Here is a brief description of the code is working:</p>
<ul>
<li>In the last two statements of the <i>Setup</i> function, we specify to call an ISR on interrupt 0 every time pin 8 changes state.</li>
<li>After the setup, the function <i>ISR(PCINT0_vect)</i> is called every time the state of the pin 8 changes from 0 to 1, or from 1 to 0.</li>
<li>The code in the function increment the variable <i>pulseCount</i> when the state of the pin changes from 0 to 1.</li>
<li>The code also get the current time in microseconds when the state of the pin changes from 0 to 1.</li>
<li>The function <i>ISR(PCINT0_vect)</i> holds the time in microseconds of the last 16 pulses (changes from 0 to 1).
To determine the RPM, instead of using the elapsed time for the last pulse, we used the elapsed time for the last 16 pulses.
This is used to smooth out the RPM value.</li>
<li>The current RPM value is saved in a global variable named <i>rpm</i>.</li>
<li>The function <i>getRPM</i> is used to get the RPM value from the global variable. Because the value is stored in an non-atomic type for the Arduino
(many CPU instructions are needed to modify or read it), the <i>getRPM</i> function has to disable the interrupts (cli) before reading it.
Without the cli statement, we could read the first part of the value, then the ISR could change the value, and after that we could read the last part of the value.
This would lead to getting the wrong value.</li>
</ul>
<p>The complete code could be found in the figure 6 below.<p>
<figure>
	<div class="code">
<pre>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// Number of pulses to use while computing the RPM.
#define PULSE_COUNT   16

LiquidCrystal_I2C lcd(0x27, 16, 2);

// Count of pulses from the engine.
static uint32_t pulseCount = 0;

// Current RPM value computed with the elapsed time of the last 16 pulses. 
static uint16_t rpm = 0;

// Get the count of pulses from the engine.
uint32_t getPulseCount()
{
  // Disable interrupts while we read the count value. This way we will be sure that the ISR will not change it while we are reading it.
  cli();
  uint32_t count = pulseCount;
  sei();
  return count;
}

// Get the current RPM value.
uint16_t getRPM()
{
  // Disable interrupts while we read the RPM value. This way we will be sure that the ISR will not change it while we are reading it.
  cli();
  uint16_t value = rpm;
  sei();
  return value;
}

void setup()
{
  Serial.begin(9600);
  lcd.init();
  lcd.backlight();

  // We count engine pulse on pin 8.
  pinMode(8, INPUT);

  // Allow pin change interrupts for PB0 (digital pin 8).  
  PCMSK0 = (1 << PINB0);

  // Enable pin change interrupt 0.
  PCICR = (1 << PCIE0);
}

// Interrupt service routine for the interrupt 0.
// This function is called every time the state of pin 8 changes.
ISR(PCINT0_vect)
{
  static unsigned long previousMicros[PULSE_COUNT] = {0};   // Time in microseconds for the last PULSE_COUNT pulses.
  static uint8_t index = 0;                                 // Current index in previousMicros.
  static uint8_t previousState = 0;                         // Previous state of the pin 8.
  uint8_t state = (PINB >> PINB0) & 0x01;                   // Current state of the pin 8.
  
  if (state != previousState) {
    // Count only changes from 0 to 1.
    if (state != 0) {
      ++pulseCount;

      // Increment the index in our array of previous times in microseconds.
      if (++index >= PULSE_COUNT) {
        index = 0;      
      }

      // Compute the elapsed time in microseconds for the last PULSE_COUNT pulses.
      unsigned long currentMicros = micros();
      unsigned long elapsedMicros = currentMicros - previousMicros[index];
      previousMicros[index] = currentMicros;

      // Compute the RPM using the elapsed time in microseconds for the last PULSE_COUNT pulses.
      rpm = (uint16_t)((60 * 1000000UL * PULSE_COUNT + elapsedMicros / 2) / elapsedMicros);
    }
    previousState = state;
  }
}

void loop()
{
  uint16_t rpm = getRPM();
  unsigned long pulseCount = getPulseCount();
  
  Serial.print(rpm);
  Serial.print(" ");
  Serial.println(pulseCount);
  
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print(rpm);
  lcd.setCursor(0,1);
  lcd.print(pulseCount);
  
  delay(500);
}</pre>
	</div>
	<figcaption>Figure 6 - Complete code for measuring the engine's RPM using an ISR</figcaption>
</figure>
	
	
	<!---- 07/11/2015: Pulse generator using a timer --->
	<hr>
    <a name="PulseGeneratorUsingTimer"><h2>07/11/2015: Pulse generator using a timer</h2></a>
<p>This week, we modified the code of the pulse generator hoping to gain some accuracy. The pulse generator is used to simulate engine pulses for testing the RPM counter module.
In this version of the code, we use used a timer and an ISR (interrupt service routine) that is called every time the timer's counter reaches its maximum value.
Here is a brief description of how the code is working:</p>
<ul>
<li>The <i>setupTimer</i> function initializes the timer to generate an interrupt every <i>timeInUS</i> micro seconds. The function also attaches the function <i>timerISR</i> to the timer's interrupt.</li>
<li>The <i>setRPM</i> function transforms the given RPM value into a period time in microseconds, and calls <i>setupTimer</i>.</li>
<li>The <i>timerISR</i> function generates a pulse. It set the pin 3 to high for one millisecond.</li>
<li>The <i>loop</i> function reads an RPM value from the serial port and changes the timer to generate pulses for the given RPM value.</li>
</ul>
<p>The complete code could be found in the figure 7 below.<p>
<figure>
	<div class="code">
<pre>#include "TimerOne.h"

int defaultRPM = 2000;

void setupTimer(unsigned long timeInUs)
{
  Timer1.initialize(timeInUs);       // Initialize timer1, and set a timeInUs micro second period.
  Timer1.attachInterrupt(timerISR);  // Attaches timerISR() as a timer overflow interrupt.
}

void setRPM(int RPM)
{
  unsigned long timeInUs = 60000000 / RPM;
  setupTimer(timeInUs);
  Serial.println(timeInUs);
}

void timerISR()
{
  sei();
  digitalWrite(3, HIGH);
  delay(1); // Stay high for 1 ms.
  digitalWrite(3, LOW);
}

void setup()
{
  pinMode(3, OUTPUT);
  Serial.begin(9600);
  setRPM(defaultRPM);
}

void loop()
{
  // Read a new RPM value.
  String line = Serial.readStringUntil('\n');
  int RPM = line.toInt();
  
  if (line != "") {
   if (RPM == 0) {
    Serial.println("error");
   } else {
    Serial.print("setting RPM to ");
    Serial.println(RPM);
    
    // Set timer to generate pulses corresponding to the given RPM.
    setRPM(RPM);
   }
  }
}</pre>
	</div>
	<figcaption>Figure 7 - Complete code for generating pulses using a timer and an ISR</figcaption>
</figure>
<p>When we first checked the output pulse on an oscilloscope we found that the pulse duration in millisecond was not exactly what was expected.</p>
<p>After adding some debugging code for checking the time in microseconds needed to generate 1000 pulses, we found a match between the expected
time in microseconds measured by the Arduino and the expected duration of the pulses. This was suggesting that the code is ok and the problem lies somewhere else.</p>
<p>After some reading on the web, we found that the cheaper versions of the Arduino are using ceramic resonators instead of crystals for generating the clock. This leads to small timing errors.</p>
<p>Here is one of the nice references we found on that subject: <a href="http://jorisvr.nl/arduino_frequency.html">Arduino clock frequency stability</a>.</p>
	
      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/prouss/snowblower-rev-counter">Snowblower-rev-counter</a> is maintained by <a href="https://github.com/prouss">Pierre Rousseau</a> and <a href="https://github.com/pouti">Étienne Lapointe-Rousseau</a>.</span>
      </footer>
    </section>
  </body>
</html>
